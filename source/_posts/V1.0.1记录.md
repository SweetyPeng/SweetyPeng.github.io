---
title: V1.0.1记录
date: 2018-10-15 11:24:20
tags: [keep learning,Summary]
categories: 工作小结
copyright: true
---
## 需求概述
这次主要负责医生中心下面的订单筛选功能的实现与展示，相对来说是比较独立的功能，没有涉及太多之前的业务关系。
![one](one.png)
<!--   MORE  -->
## 涉及实现
### 一、阿里图标库的使用
上一次有提到过，但使用的时候只是照样子去使用，没真正弄清楚在这项目里怎么个使用法。这次，终于get了！
<br><b>可参考：[官网帮助中心](http://www.iconfont.cn/help/detail?spm=a313x.7781069.1998910419.15&helptype=code)</b>
1. 复制 font class 的在线链接的代码， 在浏览器中打开，复制内容到 项目的iconfont.less中
2. 现在就可以直接在class中使用
```
<text class="icon1 iconfont icon-icon_Order"></text>
```
icon1 是自定义的样式，可以对使用的图标进行一些编辑，如颜色大小。<br>
iconfont 是字体的本来样式<br>
icon-icon_Order 是图标的名称<br>

### 二、筛选栏的实现
#### 样式实现

```
<view wx:if="{{isVisible}}" >
        <view class="mask" @tap="onCancelMask"></view>
        <view class="filter-card">
          <view class="filter-list">······</view>
          <view class="filter-date">······</view>
          <view class="btn-area">······</view>
         </view>
</view>
```
##### 1、样式
这个筛选栏的样式实现是 类似于弹窗，点击“筛选”弹出选择栏，其他部分使用的蒙层。<br>

```
<view class="{{currStatus === '1' ? 'selected' : 'list-option'}}" @tap="statusSelect(1)">全部订单</view>
<view class="{{currStatus === '2' ? 'selected' : 'list-option'}}" @tap="statusSelect(2)">已开单</view>
<view class="{{currStatus === '3' ? 'selected' : 'list-option'}}" @tap="statusSelect(3)">报告已出</view>
```
#### 功能实现
##### 2、选择条件 
<br>这里我是设置了一个参数用于获取每次点击事件对应的条件，然后在对应后端给出的状态。这里，参数对应转换，有些小复杂的感觉，可能不是最佳方式，之后想到更好的方式再优化一下。
```
case '1':
   this.currState = 2; // 全部订单
   break;
case '2':
   this.currState = 1; // 已开单
   break;
case '3':
    this.currState = 3; // 报告已出
    break;
```
##### 3、时间选择
<br>直接使用的是小程序的时间选择器picker mode="date"
<br>出现的一个问题是 筛选时的结束时间 不包含所选时间，在和后端沟通之后决定直接前端传参的时候 结束时间+1天。

```
if (this.lastDate) {
    const oneDay = 1 * 24 * 60 * 60 * 1000;
    const ldate = new Date(this.lastDate).getTime();
    this.lastDate = new Date(ldate + oneDay).toJSON().substr(0, 10);
}
```
##### 4、状态转换
<br>在获取到后端返回的数据时，返回的是 数字码形式，需要转换为对应的中文形式。

```
<text>{{orderStateCN[item.orderState]}}</text>

data: {
    orderStateCN: {
      '1': '已开单',
      '2': '已送检',
      '3': '实验中'}
      }
```
<b>相关知识</b>
访问对象属性的两种方式 ： . 或 []
<br>1、先声明一个变量  例如：env = 'test'，使用domains[env]
<br>2、直接 domains.test<br>

##### 5、随机头像分配
<br>为了美观，UI要求给获取的每个列表对应一个卡通头像。
<br>因为理解不同，还闹了笑话。之前我处理是 直接生成1-5的随机数 再对应图片。结果每次进入 同一个订单的头像都会重新随机生成一次。

```
const b = Math.ceil(Math.random() * 5);
const photo = `https://biosan-saas.oss-cn-beijing.aliyuncs.com/medicClient/doctorCenter/photo-${b}.png`;

```
本来讨论说在本地进行存储，但是因为功能的重要性不大，决定直接用身份证后6位做计算，更加方便。写的一个方法，在需要的页面直接调用。

```
export const getUserAvatar = (idNo) => {
  if (idNo && !isNaN(parseInt(idNo))) {
    const a = idNo.substr(12, 6);
    const b = Math.ceil(parseInt(a) % 5 + 1);
    return `//biosan-saas.oss-cn-beijing.aliyuncs.com/medicClient/doctorCenter/photo-${b}.png`;
······
```
##### 6、获取列表（这是最主要的功能！！！）
<br>虽然说这是最主要的，实际却是最简单的，直接从后端获取接口就可以了。前提是自己要保证传参准确。
<br>关于参数问题，还是有点不自信，多练练就会好吧。

```
async getOrderList() {
    const params = {
      // doctor_id: this.doctorId,
      state_type: this.currState,
      begin_datetime: this.firstDate,
      end_datetime: this.lastDate,

      isMock: false,
      page_num: this.pageNum,
      page_size: this.pageSize
    };
    const resp = await this.GET(`/${nurseVersion}/register/orderList`, params);
    if (resp.result === 'success' && resp) {
      var temList = this.dataList;
      const list = resp.data || []
      list.map(item => {
        return Object.assign(item, {
          photo: getUserAvatar(item.idNo)
        });
      });
      this.dataList = temList.concat(list);
      this.len = list.length;
      this.$apply();
    } else {
      this.$toast(resp.message);
    }
  }
```
##### 7、小程序分页实现
<br>页面相关事件处理函数--监听用户下拉动作onPullDownRefresh() {}
<br>页面上拉触底事件的处理函数
  onReachBottom() {}
<br>有挺多技术帖也有介绍，实际使用中，也参考了一下。

```
if (resp.result === 'success' && resp) {
      var temList = this.dataList;
      const list = resp.data || []
      list.map(item => {
        return Object.assign(item, {
          photo: getUserAvatar(item.idNo)
        });
      });
      this.dataList = temList.concat(list);
```

```
// 页面上拉触底事件的处理函数
  onReachBottom() {
    if (this.len >= this.pageSize) {
      // this.$loading('加载下一页');
      this.pageNum += 1;
      this.getOrderList();
      // this.$loading(false);
    } else {
      this.$toast('已经加载全部');
    }
  }
```
### 三、一些零碎
#### wx:for和wx:key
在组件上使用wx:for控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。<br>
默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item<br>
使用 wx:for-item 可以指定数组当前元素的变量名，<br>
使用 wx:for-index 可以指定数组当前下标的变量名：

```
<view wx:for="{{array}}">
  {{index}}: {{item.message}}
</view>

<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>
```
wx:key="字符串"<br>
这个”字符串”代表在 for 循环的 array 中 item 的某个“属性”<br>
该“属性” 的值需要是列表中唯一的字符串或数字，且不能动态改变。<br>
用于被遍历的组件需要多个属性的时候。

#### Object.assign

```
var nObj = Object.assign({ },obj,obj1);
```
花括号里的叫目标对象，后面的obj、obj1是源对象。<br>
对象合并是指：将源对象里面的属性添加到目标对象中去，若两者的属性名有冲突，后面的将会覆盖前面的

#### CSS实现右三角图标

```
.right-triangle {
    width: 0;
    height: 0;
    border-bottom: 12rpx solid  rgba(93,93,93,1);
    border-left: 12rpx solid transparent;
    margin-left: 8rpx;
}
```

## 写在最后
尽管磕磕绊绊，但是更加知道自己的不足，很多零碎的地方 还是有欠缺，一些细节问题 处理不到位。
<br>之前有句话大意说，每个程序员看自己三个月前的代码，都会觉得很傻逼。
<br>在大佬眼中，我现在就是这种吧。感谢 包容和理解，感谢帮助！
#### 在累也要加油鸭！


