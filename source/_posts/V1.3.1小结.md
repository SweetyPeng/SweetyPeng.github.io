---
title: V1.3.1小结
date: 2019-01-24 09:29:22
tags: [keep learning,Summary]
categories: 工作小结
copyright: true
---
年会过后，离过年又近了，年底各项安排也基本落实。

这次V1.3.1版本 是年前最后一个迭代版本，在不涉及主要下单流程的基础上新增了核券、查看使用信息以及一些优化。

而在这次开发任务中，需求开发难度不大，工作量正常，而对之前版本出现的几个奇怪的问题处理 反倒是花费很多心思。
<!--   MORE  -->
### 小程序自身现存缺陷
- 问题描述：用户反馈表示，在表单输入姓名时，输入三个字，结果变成两个字。
在小程序社区也看到有很多人遇到同样的问题。
- 问题分析：input组件
<br>input组件，type='text'使用的是用户自己的输入键盘，在此情况下，bindinput 在使用中，对于输入的字符捕获不准确，可能造成此问题。

```
bindinput:
键盘输入时触发，event.detail = {value, cursor, keyCode}，keyCode 为键值，2.1.0 起支持，处理函数可以直接 return 一个字符串，将替换输入框的内容
```
```
bindblur:
输入框失去焦点时触发，event.detail = {value: value}
```

- 解决：能用微信内置输入法的尽量用，必须用用户键盘的输入框则使用bindblur或@blur事件代替，另外等待微信官方解决此bug

### 未解之谜
- JSON Parse Error:
unexpected token % in JSON at position 0;

涉及内容：
通过接口获取到content，把content作为url的参数传递到下一个页面，然后取出content 放到页面中，结果 上线后，时不时出现如上错误。

部分代码：

```
// getArticle()方法
async getArticle() {
    let articleResp = await this.GET(······);
    if (articleResp.result === 'success') {
      this.articleList = articleResp.data.map(item => {
        return Object.assign(item, {
          contentImg: JSON.stringify(item.content)
        });
      });
    }
    this.$broadcast('getBabySchoolArticle', this.articleList);
    this.$apply();
  }
```
```
// 通过broadcast方法将数据广播到子组件
methods = {
    onAriticleDetail(id, type, title, content) {
      this.$link(
        `/sidePackage/pages/babySchoolDetail/babySchoolDetail?articleId=${
          id}&articleType=${type}&articleTitle=${title}&content=${content}`
      );
    }
  };
```
```
// 下一个页面 取出参数content
onLoad(options) {
    this.articleId = options.articleId;
    this.title = options.articleTitle;
    this.detailImgList = JSON.parse(options.content);
```
- 关于问题的思考：

错误显示的是在使用JSON.parse()方法时，内容的第一位出现了%，但是在我取数据以及传递过程中，并没有出现过此符号。
 
 在排查前端代码没问题之后，觉得是后端返回的数据中的问题，但是咨询过后端同事，他表示他那里也不可能出现。
 
 在错误统计工具中，并没有发现关于这个问题的日志，于是乎，很是诧异，这怎么出现的。因为错误出现频率不高，又难以复现，也没收到反馈，更加觉得不知所错了。
 - 临时处理
 
取消通过url传数据，换成 将获取到的content 放入globalData 中，直接通过globalData取出数据，从而检测globalData数据的异常情况 来再次判断是哪里出的问题。等待版本上线后的使用情况~